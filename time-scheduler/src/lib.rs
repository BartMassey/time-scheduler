//! # Time Scheduler
//!
//! A flexible library for scheduling activities in time slots with customizable penalty functions.
//!
//! This library provides generic types and algorithms for solving scheduling problems where activities
//! need to be assigned to time slots and locations while minimizing a penalty function. The library
//! is designed to be flexible and can be adapted for various scheduling scenarios like conference
//! scheduling, resource allocation, and timetabling.
//!
//! ## Core Concepts
//!
//! - **Activities**: Generic items (type `A`) that need to be scheduled
//! - **Schedule**: A 2D grid of time slots and places, plus unscheduled activities
//! - **Penalty Functions**: User-defined functions that evaluate schedule quality
//! - **Local Search**: Hill-climbing algorithm with optional noise and restarts
//!
//! ## Quick Start
//!
//! ```rust
//! use time_scheduler::{Schedule, SchedulingInstance};
//!
//! // Define your activity type
//! #[derive(Clone, Debug)]
//! struct Activity {
//!     priority: usize,
//!     topic: usize,
//! }
//!
//! // Create a scheduling instance
//! let instance = SchedulingInstance {
//!     id: "example".to_string(),
//!     nplaces: 3,
//!     ntimes: 5,
//!     activities: vec![
//!         Activity { priority: 10, topic: 1 },
//!         Activity { priority: 8, topic: 2 },
//!         // ... more activities
//!     ],
//! };
//!
//! // Create an initial schedule
//! let mut schedule = Schedule::new(
//!     instance.nplaces,
//!     instance.ntimes,
//!     instance.activities.into_iter(),
//! );
//!
//! // Define a penalty function
//! let penalty_fn = |schedule: &Schedule<Activity>| {
//!     // Calculate penalty based on unscheduled activities, conflicts, etc.
//!     schedule.get_unscheduled_activities()
//!         .map(|a| a.priority as f32)
//!         .sum::<f32>()
//! };
//!
//! // Improve the schedule
//! schedule.improve(penalty_fn, None, false, Some(5));
//! ```
//!
//! ## Key Capabilities
//!
//! - **Generic Activity Types**: Use any type `A` for activities
//! - **Flexible Penalty Functions**: Define custom evaluation criteria
//! - **Local Search Optimization**: Hill-climbing with configurable parameters
//! - **Multi-restart Support**: Escape local optima with random restarts
//! - **Noise Moves**: Explore solution space with probabilistic moves
//! - **Bounds Checking**: Safe access to schedule slots with error handling
//!
//! ---
//!
//! *This documentation was generated by Claude Code (Sonnet 4)*

use ndarray::Array2;
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Error type for bounds checking when accessing schedule slots.
///
/// This error is returned when attempting to access a schedule slot with
/// invalid place or time coordinates.
#[derive(Debug, Error)]
pub enum BoundsError {
    /// Place index is out of bounds.
    ///
    /// The place index provided is greater than or equal to the number of places
    /// in the schedule.
    #[error("Place index {0} is out of bounds")]
    Place(usize),

    /// Time index is out of bounds.
    ///
    /// The time index provided is greater than or equal to the number of time slots
    /// in the schedule.
    #[error("Time index {0} is out of bounds")]
    Time(usize),
}

/// A scheduling problem instance containing activities and grid dimensions.
///
/// This structure represents a complete scheduling problem: a set of activities
/// that need to be assigned to a grid of places and time slots.
///
/// # Type Parameters
///
/// * `A` - The type of activities to be scheduled
///
/// # Examples
///
/// ```rust
/// use time_scheduler::SchedulingInstance;
///
/// #[derive(Clone)]
/// struct Task {
///     name: String,
///     duration: usize,
/// }
///
/// let instance = SchedulingInstance {
///     id: "my-problem".to_string(),
///     nplaces: 3,     // 3 rooms
///     ntimes: 8,      // 8 time slots
///     activities: vec![
///         Task { name: "Meeting A".to_string(), duration: 1 },
///         Task { name: "Meeting B".to_string(), duration: 2 },
///     ],
/// };
/// ```
#[derive(Debug, Serialize, Deserialize)]
pub struct SchedulingInstance<A> {
    /// Unique identifier for this problem instance
    pub id: String,

    /// Number of places (rooms, locations, etc.) available for scheduling
    pub nplaces: usize,

    /// Number of time slots in the schedule
    pub ntimes: usize,

    /// Activities that need to be scheduled
    pub activities: Vec<A>,
}

/// Internal representation of a location in the schedule.
///
/// This enum is used internally by the optimization algorithm to represent
/// either a slot in the 2D grid or a position in the unscheduled activities list.
#[derive(Debug, Clone, Copy)]
enum Loc {
    /// A slot in the 2D schedule grid at (place, time)
    S(usize, usize),
    /// An index in the unscheduled activities vector
    U(usize),
}

/// A schedule representing the assignment of activities to time slots and places.
///
/// The schedule maintains a 2D grid where activities can be placed at specific
/// (place, time) coordinates, plus a list of activities that haven't been scheduled yet.
/// Activities can be moved between slots and the unscheduled list during optimization.
///
/// # Type Parameters
///
/// * `A` - The type of activities being scheduled. Must implement `Clone`.
///
/// # Examples
///
/// ```rust
/// use time_scheduler::Schedule;
///
/// #[derive(Clone, Debug)]
/// struct Meeting {
///     title: String,
///     priority: usize,
/// }
///
/// let activities = vec![
///     Meeting { title: "Daily Standup".to_string(), priority: 10 },
///     Meeting { title: "Sprint Planning".to_string(), priority: 8 },
/// ];
///
/// let mut schedule = Schedule::new(2, 3, activities.into_iter());
///
/// // Access scheduled activities
/// if let Ok(Some(meeting)) = schedule.get_activity_at(0, 0) {
///     println!("Meeting at (0,0): {}", meeting.title);
/// }
///
/// // Count unscheduled activities
/// let unscheduled_count = schedule.get_unscheduled_activities().count();
/// println!("Unscheduled: {}", unscheduled_count);
/// ```
#[derive(Debug, Clone)]
pub struct Schedule<A> {
    /// 2D array of schedule slots, indexed by (place, time)
    slots: Array2<Option<A>>,

    /// Activities that haven't been assigned to a slot yet
    unscheduled: Vec<Option<A>>,
}

impl<A: Clone> Schedule<A> {
    /// Create a new schedule with the given dimensions and activities.
    ///
    /// Activities are initially placed in the schedule grid in row-major order.
    /// If there are more activities than grid slots, the excess activities
    /// remain unscheduled. If there are fewer activities than slots, some
    /// slots will be empty.
    ///
    /// # Arguments
    ///
    /// * `nplaces` - Number of places (columns) in the schedule grid
    /// * `ntimes` - Number of time slots (rows) in the schedule grid  
    /// * `activities` - Iterator of activities to be scheduled
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Task(String);
    ///
    /// let tasks = vec![Task("A".to_string()), Task("B".to_string())];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    /// // Creates a 2x2 grid with tasks A and B scheduled, 2 empty slots
    /// ```
    pub fn new<I>(nplaces: usize, ntimes: usize, activities: I) -> Self
    where
        I: Iterator<Item = A>,
    {
        let mut acts = activities.fuse();

        let mut slots = Array2::from_elem((nplaces, ntimes), None);
        for x in &mut slots {
            if let Some(a) = acts.next() {
                *x = Some(a)
            } else {
                break;
            }
        }

        let unscheduled = acts.map(Some).collect();

        Self { slots, unscheduled }
    }

    /// Get the activity scheduled at a specific place and time.
    ///
    /// Returns `Ok(Some(activity))` if there's an activity at the given coordinates,
    /// `Ok(None)` if the slot is empty, or `Err(BoundsError)` if the coordinates
    /// are out of bounds.
    ///
    /// # Arguments
    ///
    /// * `place` - The place index (0-based)
    /// * `time` - The time slot index (0-based)
    ///
    /// # Errors
    ///
    /// Returns [`BoundsError::Place`] if `place >= nplaces` or [`BoundsError::Time`]
    /// if `time >= ntimes`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::{Schedule, BoundsError};
    ///
    /// #[derive(Clone)]
    /// struct Task(i32);
    ///
    /// let tasks = vec![Task(1), Task(2)];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    ///
    /// match schedule.get_activity_at(0, 0) {
    ///     Ok(Some(task)) => println!("Task: {}", task.0),
    ///     Ok(None) => println!("Empty slot"),
    ///     Err(BoundsError::Place(p)) => println!("Invalid place: {}", p),
    ///     Err(BoundsError::Time(t)) => println!("Invalid time: {}", t),
    /// }
    /// ```
    pub fn get_activity_at(&self, place: usize, time: usize) -> Result<Option<&A>, BoundsError> {
        let (nplaces, ntimes) = self.slots.dim();
        if place >= nplaces {
            return Err(BoundsError::Place(place));
        }
        if time >= ntimes {
            return Err(BoundsError::Time(time));
        }
        Ok(self.slots[(place, time)].as_ref())
    }

    /// Get an iterator over all unscheduled activities.
    ///
    /// Returns an iterator that yields references to activities that haven't
    /// been assigned to any time slot yet.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Task { priority: usize }
    ///
    /// let tasks = vec![Task { priority: 1 }, Task { priority: 2 }];
    /// let schedule = Schedule::new(1, 1, tasks.into_iter()); // Only 1 slot
    ///
    /// let unscheduled_count = schedule.get_unscheduled_activities().count();
    /// println!("Unscheduled: {}", unscheduled_count); // Should be 1
    ///
    /// let total_priority: usize = schedule.get_unscheduled_activities()
    ///     .map(|task| task.priority)
    ///     .sum();
    /// ```
    pub fn get_unscheduled_activities(&self) -> impl Iterator<Item = &A> {
        self.unscheduled.iter().filter_map(|opt| opt.as_ref())
    }

    /// Get the dimensions of the schedule grid.
    ///
    /// Returns a tuple `(nplaces, ntimes)` representing the number of places
    /// and time slots in the schedule.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// let schedule = Schedule::new(3, 5, std::iter::empty::<i32>());
    /// let (places, times) = schedule.dimensions();
    /// assert_eq!(places, 3);
    /// assert_eq!(times, 5);
    /// ```
    pub fn dimensions(&self) -> (usize, usize) {
        self.slots.dim()
    }

    /// Count the number of empty slots in the schedule.
    ///
    /// Returns the total number of schedule slots that don't currently
    /// have an activity assigned to them.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// let schedule = Schedule::new(2, 2, vec![1, 2].into_iter()); // 4 slots, 2 activities
    /// assert_eq!(schedule.empty_slots_count(), 2);
    /// ```
    pub fn empty_slots_count(&self) -> usize {
        self.slots.iter().filter(|opt| opt.is_none()).count()
    }

    /// Get direct access to the internal slots array.
    ///
    /// This method provides access to the underlying 2D array for advanced
    /// penalty function implementations that need to examine the schedule
    /// structure directly. The array is indexed as `slots[(place, time)]`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    /// use ndarray::Axis;
    ///
    /// #[derive(Clone)]
    /// struct Task { id: usize }
    ///
    /// let tasks = vec![Task { id: 1 }, Task { id: 2 }];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    ///
    /// // Count activities in each time slot
    /// for (time, row) in schedule.slots().axis_iter(Axis(1)).enumerate() {
    ///     let count = row.iter().filter(|slot| slot.is_some()).count();
    ///     println!("Time {}: {} activities", time, count);
    /// }
    /// ```
    pub fn slots(&self) -> &Array2<Option<A>> {
        &self.slots
    }

    fn reshuffle(&mut self) {
        use fastrand::usize as random_usize;

        // Collect all activities from both slots and unscheduled
        let mut all_activities = Vec::new();

        // Collect from slots
        for slot in self.slots.iter_mut() {
            if let Some(activity) = slot.take() {
                all_activities.push(activity);
            }
        }

        // Collect from unscheduled
        for unscheduled_slot in self.unscheduled.iter_mut() {
            if let Some(activity) = unscheduled_slot.take() {
                all_activities.push(activity);
            }
        }

        // Shuffle the activities
        for i in (1..all_activities.len()).rev() {
            let j = random_usize(0..=i);
            all_activities.swap(i, j);
        }

        // Redistribute activities: fill slots first, then unscheduled
        let mut activity_iter = all_activities.into_iter();

        // Fill slots
        for slot in self.slots.iter_mut() {
            if let Some(activity) = activity_iter.next() {
                *slot = Some(activity);
            }
        }

        // Fill unscheduled
        for unscheduled_slot in self.unscheduled.iter_mut() {
            if let Some(activity) = activity_iter.next() {
                *unscheduled_slot = Some(activity);
            }
        }
    }

    fn swap_locations(&mut self, loc1: Loc, loc2: Loc) {
        use Loc::*;

        let activity1 = match loc1 {
            S(p, t) => self.slots[(p, t)].take(),
            U(i) => self.unscheduled[i].take(),
        };
        let activity2 = match loc2 {
            S(p, t) => self.slots[(p, t)].take(),
            U(i) => self.unscheduled[i].take(),
        };

        match loc1 {
            S(p, t) => self.slots[(p, t)] = activity2,
            U(i) => self.unscheduled[i] = activity2,
        }
        match loc2 {
            S(p, t) => self.slots[(p, t)] = activity1,
            U(i) => self.unscheduled[i] = activity1,
        }
    }
}

impl<A: Clone> Schedule<A> {
    /// Improve the schedule using local search optimization.
    ///
    /// This method uses a hill-climbing algorithm to improve the schedule by
    /// trying swaps between different locations and keeping beneficial changes.
    /// You provide a penalty function that evaluates the quality of the schedule.
    ///
    /// The algorithm works by:
    /// 1. Trying all possible swaps between locations (schedule slots and unscheduled list)
    /// 2. Keeping the swap that gives the best improvement
    /// 3. Repeating until no improvement is found or max swaps reached
    /// 4. Optionally restarting with a random reshuffle to escape local optima
    ///
    /// # Arguments
    ///
    /// * `penalty_fn` - Function that takes a schedule reference and returns a penalty score.
    ///   Lower scores are better, with 0.0 representing a perfect solution.
    /// * `nswaps` - Maximum number of swap iterations per restart. If `None`,
    ///   defaults to `2 * (total_locations)^3`
    /// * `noise` - If `true`, occasionally makes random moves instead of greedy ones
    /// * `restarts` - Number of restarts with random reshuffling. If `None` or `0`,
    ///   no restarts are performed
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Meeting {
    ///     priority: usize,
    ///     topic: usize,
    /// }
    ///
    /// let meetings = vec![
    ///     Meeting { priority: 10, topic: 1 },
    ///     Meeting { priority: 8, topic: 2 },
    ///     Meeting { priority: 6, topic: 1 },
    /// ];
    ///
    /// let mut schedule = Schedule::new(2, 2, meetings.into_iter());
    ///
    /// // Define penalty function that penalizes unscheduled high-priority meetings
    /// let penalty_fn = |schedule: &Schedule<Meeting>| {
    ///     let unscheduled_penalty: f32 = schedule.get_unscheduled_activities()
    ///         .map(|m| m.priority as f32)
    ///         .sum();
    ///     
    ///     let empty_slots_penalty = schedule.empty_slots_count() as f32 * 100.0;
    ///     
    ///     unscheduled_penalty + empty_slots_penalty
    /// };
    ///
    /// // Optimize with 5 restarts and noise
    /// schedule.improve(penalty_fn, None, true, Some(5));
    /// ```
    pub fn improve<F>(
        &mut self,
        penalty_fn: F,
        nswaps: Option<usize>,
        noise: bool,
        restarts: Option<usize>,
    ) where
        F: Fn(&Schedule<A>) -> f32,
    {
        let num_restarts = restarts.unwrap_or(0);

        // Single run case: optimize once and return
        if num_restarts == 0 {
            self.improve_single(&penalty_fn, nswaps, noise);
            return;
        }

        // Run first optimization and track as initial best
        self.improve_single(&penalty_fn, nswaps, noise);
        let mut best_penalty = penalty_fn(self);
        let mut best_schedule = self.clone();

        // Try additional restarts with reshuffling
        for _ in 0..num_restarts {
            self.reshuffle();
            self.improve_single(&penalty_fn, nswaps, noise);
            let current_penalty = penalty_fn(self);

            // Update best if this restart found a better solution
            if current_penalty < best_penalty {
                best_penalty = current_penalty;
                best_schedule = self.clone();
            }
        }

        // Restore the best solution found across all runs
        *self = best_schedule;
    }

    fn improve_single<F>(&mut self, penalty_fn: &F, nswaps: Option<usize>, noise: bool)
    where
        F: Fn(&Schedule<A>) -> f32,
    {
        use fastrand::usize as random_usize;
        use Loc::*;

        // Setup: calculate dimensions and generate all possible locations
        let (nplaces, ntimes) = self.slots.dim();
        let nunscheduled = self.unscheduled.len();
        let ntotal = nplaces * ntimes + nunscheduled;
        let nswaps = nswaps.unwrap_or(2 * usize::pow(ntotal, 3));

        let all_locations: Vec<Loc> = (0..nplaces)
            .flat_map(|p| (0..ntimes).map(move |t| S(p, t)))
            .chain((0..nunscheduled).map(U))
            .collect();

        // Initialize best solution tracking for this single run
        let mut best_penalty = penalty_fn(self);
        let mut best_schedule = self.clone();
        let mut penalty = best_penalty;

        // Main optimization loop: try up to nswaps improvements
        for _ in 0..nswaps {
            // Noise move: random swap that may disimprove (escape local optima)
            if noise && random_usize(0..2) == 0 {
                let i = random_usize(0..ntotal);
                let j = random_usize(0..ntotal);
                self.swap_locations(all_locations[i], all_locations[j]);
                let new_penalty = penalty_fn(self);
                
                // Always accept noise moves (even if they disimprove)
                penalty = new_penalty;
                
                // Update best if this noise move happened to improve
                if new_penalty < best_penalty {
                    best_penalty = new_penalty;
                    best_schedule = self.clone();
                }
                continue;
            }

            // Greedy move: find the best improving swap among all possibilities
            let mut cur_best = None;
            let mut cur_penalty = penalty;
            for i in 0..ntotal {
                for j in i + 1..ntotal {
                    self.swap_locations(all_locations[i], all_locations[j]);
                    let new_penalty = penalty_fn(self);
                    if cur_penalty > new_penalty {
                        cur_best = Some((i, j));
                        cur_penalty = new_penalty;
                    }
                    self.swap_locations(all_locations[j], all_locations[i]);
                }
            }
            // Apply the best greedy move if one was found
            if let Some((i, j)) = cur_best {
                self.swap_locations(all_locations[i], all_locations[j]);
                penalty = cur_penalty;
                
                // Update best if this greedy move improved our overall best
                if penalty < best_penalty {
                    best_penalty = penalty;
                    best_schedule = self.clone();
                }
            }
        }

        // Restore the best solution found during this single run
        *self = best_schedule;
    }
}
