#![doc(html_root_url = "https://docs.rs/time-scheduler/0.1.0")]

//! # Time Scheduler
//!
//! A flexible library for scheduling activities in time slots with customizable penalty functions.
//!
//! This library provides generic types and algorithms for solving scheduling problems where activities
//! need to be assigned to time slots and locations while minimizing a penalty function. The library
//! is designed to be flexible and can be adapted for various scheduling scenarios like conference
//! scheduling, resource allocation, and timetabling.
//!
//! ## Core Concepts
//!
//! - **Activities**: Generic items (type `A`) that need to be scheduled
//! - **Schedule**: A 2D grid of time slots and places, plus unscheduled activities
//! - **Penalty Functions**: User-defined functions that evaluate schedule quality
//! - **Local Search**: Hill-climbing algorithm with optional noise and restarts
//!
//! ## Quick Start
//!
//! ```rust
//! use time_scheduler::{Schedule, SchedulingInstance};
//!
//! // Define your activity type
//! #[derive(Clone, Debug)]
//! struct Activity {
//!     priority: usize,
//!     topic: usize,
//! }
//!
//! // Create a scheduling instance
//! let instance = SchedulingInstance {
//!     id: "example".to_string(),
//!     nplaces: 3,
//!     ntimes: 5,
//!     activities: vec![
//!         Activity { priority: 10, topic: 1 },
//!         Activity { priority: 8, topic: 2 },
//!         // ... more activities
//!     ],
//! };
//!
//! // Create an initial schedule
//! let mut schedule = Schedule::new(
//!     instance.nplaces,
//!     instance.ntimes,
//!     instance.activities.into_iter(),
//! );
//!
//! // Improve the schedule with a penalty function returning (unscheduled_count, other_penalty)
//! schedule.improve(|schedule: &Schedule<Activity>| {
//!     let unscheduled_count = schedule.get_unscheduled_activities().count()
//!                           + schedule.empty_slots_count();
//!     let priority_penalty = schedule.get_unscheduled_activities()
//!         .map(|a| a.priority as f32)
//!         .sum::<f32>();
//!     (unscheduled_count, priority_penalty)
//! }).with_noise().restarts(5).run();
//! ```
//!
//! ## Key Capabilities
//!
//! - **Generic Activity Types**: Use any type `A` for activities
//! - **Flexible Penalty Functions**: Define custom evaluation criteria
//! - **Local Search Improvement**: Hill-climbing with configurable parameters
//! - **Multi-restart Support**: Escape local optima with random restarts
//! - **Noise Moves**: Explore solution space with probabilistic moves
//! - **Bounds Checking**: Safe access to schedule slots with error handling
//!
//! ---
//!
//! *This documentation was generated by Claude Code (Sonnet 4)*

use ndarray::Array2;
use serde::{Deserialize, Serialize};
use std::time::{Duration, Instant};
use thiserror::Error;

/// Adaptive timeout checker that measures swaps-per-second and adjusts checking frequency.
struct TimeoutChecker {
    timeout_duration: Duration,
    start_time: Instant,
    next_check: usize,
    swaps_per_sec: Option<f64>,
}

impl TimeoutChecker {
    fn new(timeout_duration: Duration) -> Self {
        Self {
            timeout_duration,
            start_time: Instant::now(),
            next_check: 10, // Start with 10 swaps to get initial estimate
            swaps_per_sec: None,
        }
    }

    /// Check if timeout should occur. Call before every swap.
    fn should_timeout(&mut self, swap_iter: usize) -> bool {
        if swap_iter < self.next_check {
            return false;
        }

        let elapsed = self.start_time.elapsed();
        if elapsed > self.timeout_duration {
            return true;
        }

        // Update swaps-per-second estimate
        self.swaps_per_sec = Some(swap_iter as f64 / elapsed.as_secs_f64());

        // Calculate remaining time and estimated remaining swaps
        let remaining_time = self.timeout_duration.as_secs_f64() - elapsed.as_secs_f64();
        if let Some(sps) = self.swaps_per_sec {
            let estimated_remaining_swaps = (sps * remaining_time).max(0.0) as usize;

            // Set next check point
            if estimated_remaining_swaps <= 10 {
                self.next_check = swap_iter + 1; // Single-step when close to end
            } else {
                self.next_check = swap_iter + (estimated_remaining_swaps / 2).max(1);
            }
        } else {
            // Fallback if calculation fails
            self.next_check = swap_iter + 100;
        }

        false
    }
}

/// Error type for bounds checking when accessing schedule slots.
///
/// This error is returned when attempting to access a schedule slot with
/// invalid place or time coordinates.
#[derive(Debug, Error)]
pub enum BoundsError {
    /// Place index is out of bounds.
    ///
    /// The place index provided is greater than or equal to the number of places
    /// in the schedule.
    #[error("Place index {0} is out of bounds")]
    Place(usize),

    /// Time index is out of bounds.
    ///
    /// The time index provided is greater than or equal to the number of time slots
    /// in the schedule.
    #[error("Time index {0} is out of bounds")]
    Time(usize),
}

/// A scheduling problem instance containing activities and grid dimensions.
///
/// This structure represents a complete scheduling problem: a set of activities
/// that need to be assigned to a grid of places and time slots.
///
/// # Type Parameters
///
/// * `A` - The type of activities to be scheduled
///
/// # Examples
///
/// ```rust
/// use time_scheduler::SchedulingInstance;
///
/// #[derive(Clone)]
/// struct Task {
///     name: String,
///     duration: usize,
/// }
///
/// let instance = SchedulingInstance {
///     id: "my-problem".to_string(),
///     nplaces: 3,     // 3 rooms
///     ntimes: 8,      // 8 time slots
///     activities: vec![
///         Task { name: "Meeting A".to_string(), duration: 1 },
///         Task { name: "Meeting B".to_string(), duration: 2 },
///     ],
/// };
/// ```
#[derive(Debug, Serialize, Deserialize)]
pub struct SchedulingInstance<A> {
    /// Unique identifier for this problem instance
    pub id: String,

    /// Number of places (rooms, locations, etc.) available for scheduling
    pub nplaces: usize,

    /// Number of time slots in the schedule
    pub ntimes: usize,

    /// Activities that need to be scheduled
    pub activities: Vec<A>,
}

/// Internal representation of a location in the schedule.
///
/// This enum is used internally by the optimization algorithm to represent
/// either a slot in the 2D grid or a position in the unscheduled activities list.
#[derive(Debug, Clone, Copy)]
enum Loc {
    /// A slot in the 2D schedule grid at (place, time)
    S(usize, usize),
    /// An index in the unscheduled activities vector
    U(usize),
}

/// A schedule representing the assignment of activities to time slots and places.
///
/// The schedule maintains a 2D grid where activities can be placed at specific
/// (place, time) coordinates, plus a list of activities that haven't been scheduled yet.
/// Activities can be moved between slots and the unscheduled list during optimization.
///
/// # Type Parameters
///
/// * `A` - The type of activities being scheduled. Must implement `Clone`.
///
/// # Examples
///
/// ```rust
/// use time_scheduler::Schedule;
///
/// #[derive(Clone, Debug)]
/// struct Meeting {
///     title: String,
///     priority: usize,
/// }
///
/// let activities = vec![
///     Meeting { title: "Daily Standup".to_string(), priority: 10 },
///     Meeting { title: "Sprint Planning".to_string(), priority: 8 },
/// ];
///
/// let mut schedule = Schedule::new(2, 3, activities.into_iter());
///
/// // Access scheduled activities
/// if let Ok(Some(meeting)) = schedule.get_activity_at(0, 0) {
///     println!("Meeting at (0,0): {}", meeting.title);
/// }
///
/// // Count unscheduled activities
/// let unscheduled_count = schedule.get_unscheduled_activities().count();
/// println!("Unscheduled: {}", unscheduled_count);
/// ```
#[derive(Debug, Clone)]
pub struct Schedule<A> {
    /// 2D array of schedule slots, indexed by (place, time)
    slots: Array2<Option<A>>,

    /// Activities that haven't been assigned to a slot yet
    unscheduled: Vec<Option<A>>,
}

/// Builder for configuring schedule improvement parameters.
///
/// Provides a fluent API for setting improvement parameters with sensible defaults.
/// Use [`Schedule::improve`] to create an improver instance.
///
/// # Examples
///
/// ```rust
/// use time_scheduler::Schedule;
///
/// #[derive(Clone)]
/// struct Task { priority: usize }
///
/// let mut schedule = Schedule::new(3, 5, vec![Task { priority: 10 }].into_iter());
///
/// // Simple improvement with defaults
/// schedule.improve(|s: &Schedule<Task>| (s.empty_slots_count(), 0.0f32)).run();
///
/// // Customized improvement
/// schedule.improve(|s: &Schedule<Task>| (s.empty_slots_count(), 0.0f32))
///     .max_swaps(5000)
///     .with_noise()
///     .restarts(10)
///     .run();
/// ```
pub struct Improver<'a, A, F> {
    schedule: &'a mut Schedule<A>,
    penalty_fn: F,
    max_swaps: Option<usize>,
    noise: bool,
    restarts: Option<usize>,
    timeout: Option<Duration>,
    proportional_restarts: bool,
}

impl<'a, A: Clone, F, P> Improver<'a, A, F>
where
    F: Fn(&Schedule<A>) -> P,
    P: Copy + PartialOrd,
{
    fn new(schedule: &'a mut Schedule<A>, penalty_fn: F) -> Self {
        Self {
            schedule,
            penalty_fn,
            max_swaps: None,
            noise: false,
            restarts: None,
            timeout: None,
            proportional_restarts: false,
        }
    }

    /// Set the maximum number of swap attempts per improvement run.
    ///
    /// If not specified, defaults to `5 * (total_locations)^2`. Note that pure
    /// greedy search (without noise) will terminate early when no improvement
    /// is found, making this limit primarily relevant for noisy search.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use time_scheduler::Schedule;
    /// let mut schedule = Schedule::new(2, 2, std::iter::empty::<i32>());
    /// schedule.improve(|_| (0usize, 0.0f32)).max_swaps(1000).run();
    /// ```
    pub fn max_swaps(mut self, max_swaps: usize) -> Self {
        self.max_swaps = Some(max_swaps);
        self
    }

    /// Enable noise moves that can temporarily worsen the solution.
    ///
    /// Noise moves help escape local optima by occasionally making random moves
    /// that may increase the penalty. The algorithm still tracks and returns
    /// the best solution found.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use time_scheduler::Schedule;
    /// let mut schedule = Schedule::new(2, 2, std::iter::empty::<i32>());
    /// schedule.improve(|_| (0usize, 0.0f32)).with_noise().run();
    /// ```
    pub fn with_noise(mut self) -> Self {
        self.noise = true;
        self
    }

    /// Set the total number of improvement runs (including the initial run).
    ///
    /// Values of 0 or 1 result in a single run with no restarts. Values ≥ 2
    /// perform additional restarts with random reshuffling. Each restart begins
    /// with a random reshuffling of the current schedule, then runs a full
    /// improvement process. The best solution across all runs is returned.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use time_scheduler::Schedule;
    /// let mut schedule = Schedule::new(2, 2, std::iter::empty::<i32>());
    /// schedule.improve(|_| (0usize, 0.0f32)).restarts(5).run();
    /// ```
    pub fn restarts(mut self, restarts: usize) -> Self {
        self.restarts = Some(restarts);
        self
    }

    /// Set the total number of runs with proportional resource division.
    ///
    /// This method provides fair comparison between different restart strategies
    /// by dividing the total swap and timeout budgets across all runs. For example, if
    /// `max_swaps(1000).restarts_proportional(5)` is used, each of the 5 runs
    /// will get 200 swaps instead of 1000 each. Similarly for timeouts.
    ///
    /// If `max_swaps` was not explicitly set, the default budget is calculated
    /// first, then divided across restarts.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use time_scheduler::Schedule;
    /// let mut schedule = Schedule::new(2, 2, std::iter::empty::<i32>());
    /// // 1000 total swaps divided across 5 runs = 200 swaps per run
    /// schedule.improve(|_| (0usize, 0.0f32)).max_swaps(1000).restarts_proportional(5).run();
    /// ```
    pub fn restarts_proportional(mut self, restarts: usize) -> Self {
        self.restarts = Some(restarts);
        self.proportional_restarts = true;
        self
    }

    /// Set a runtime timeout for the improvement process.
    ///
    /// Uses an adaptive timeout checking algorithm that measures swaps-per-second
    /// and adjusts checking frequency dynamically. Starts with 10 swaps to estimate
    /// performance, then checks at intervals of half the estimated remaining swaps.
    /// When within 10 swaps of completion, checks every swap for maximum accuracy.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use time_scheduler::Schedule;
    /// # use std::time::Duration;
    /// let mut schedule = Schedule::new(2, 2, std::iter::empty::<i32>());
    /// // Limit improvement to 5 seconds maximum
    /// schedule.improve(|_| (0usize, 0.0f32)).timeout(Duration::from_secs(5)).run();
    /// ```
    pub fn timeout(mut self, duration: Duration) -> Self {
        self.timeout = Some(duration);
        self
    }

    /// Run the improvement with the configured parameters.
    ///
    /// This consumes the improver and applies the improvement to the schedule.
    /// The schedule will be left in the best state found during improvement.
    pub fn run(self) {
        self.schedule.improve_run(
            self.penalty_fn,
            self.max_swaps,
            self.noise,
            self.restarts,
            self.timeout,
            self.proportional_restarts,
        );
    }
}

impl<A: Clone> Schedule<A> {
    /// Create a new schedule with the given dimensions and activities.
    ///
    /// Activities are initially placed in the schedule grid in row-major order.
    /// If there are more activities than grid slots, the excess activities
    /// remain unscheduled. If there are fewer activities than slots, some
    /// slots will be empty.
    ///
    /// # Arguments
    ///
    /// * `nplaces` - Number of places (columns) in the schedule grid
    /// * `ntimes` - Number of time slots (rows) in the schedule grid  
    /// * `activities` - Iterator of activities to be scheduled
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Task(String);
    ///
    /// let tasks = vec![Task("A".to_string()), Task("B".to_string())];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    /// // Creates a 2x2 grid with tasks A and B scheduled, 2 empty slots
    /// ```
    pub fn new<I>(nplaces: usize, ntimes: usize, activities: I) -> Self
    where
        I: Iterator<Item = A>,
    {
        let mut acts = activities.fuse();

        let mut slots = Array2::from_elem((nplaces, ntimes), None);
        for x in &mut slots {
            if let Some(a) = acts.next() {
                *x = Some(a)
            } else {
                break;
            }
        }

        let unscheduled = acts.map(Some).collect();

        Self { slots, unscheduled }
    }

    /// Get the activity scheduled at a specific place and time.
    ///
    /// Returns `Ok(Some(activity))` if there's an activity at the given coordinates,
    /// `Ok(None)` if the slot is empty, or `Err(BoundsError)` if the coordinates
    /// are out of bounds.
    ///
    /// # Arguments
    ///
    /// * `place` - The place index (0-based)
    /// * `time` - The time slot index (0-based)
    ///
    /// # Errors
    ///
    /// Returns [`BoundsError::Place`] if `place >= nplaces` or [`BoundsError::Time`]
    /// if `time >= ntimes`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::{Schedule, BoundsError};
    ///
    /// #[derive(Clone)]
    /// struct Task(i32);
    ///
    /// let tasks = vec![Task(1), Task(2)];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    ///
    /// match schedule.get_activity_at(0, 0) {
    ///     Ok(Some(task)) => println!("Task: {}", task.0),
    ///     Ok(None) => println!("Empty slot"),
    ///     Err(BoundsError::Place(p)) => println!("Invalid place: {}", p),
    ///     Err(BoundsError::Time(t)) => println!("Invalid time: {}", t),
    /// }
    /// ```
    pub fn get_activity_at(&self, place: usize, time: usize) -> Result<Option<&A>, BoundsError> {
        let (nplaces, ntimes) = self.slots.dim();
        if place >= nplaces {
            return Err(BoundsError::Place(place));
        }
        if time >= ntimes {
            return Err(BoundsError::Time(time));
        }
        Ok(self.slots[(place, time)].as_ref())
    }

    /// Get an iterator over all unscheduled activities.
    ///
    /// Returns an iterator that yields references to activities that haven't
    /// been assigned to any time slot yet.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Task { priority: usize }
    ///
    /// let tasks = vec![Task { priority: 1 }, Task { priority: 2 }];
    /// let schedule = Schedule::new(1, 1, tasks.into_iter()); // Only 1 slot
    ///
    /// let unscheduled_count = schedule.get_unscheduled_activities().count();
    /// println!("Unscheduled: {}", unscheduled_count); // Should be 1
    ///
    /// let total_priority: usize = schedule.get_unscheduled_activities()
    ///     .map(|task| task.priority)
    ///     .sum();
    /// ```
    pub fn get_unscheduled_activities(&self) -> impl Iterator<Item = &A> {
        self.unscheduled.iter().filter_map(|opt| opt.as_ref())
    }

    /// Get the dimensions of the schedule grid.
    ///
    /// Returns a tuple `(nplaces, ntimes)` representing the number of places
    /// and time slots in the schedule.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// let schedule = Schedule::new(3, 5, std::iter::empty::<i32>());
    /// let (places, times) = schedule.dimensions();
    /// assert_eq!(places, 3);
    /// assert_eq!(times, 5);
    /// ```
    pub fn dimensions(&self) -> (usize, usize) {
        self.slots.dim()
    }

    /// Count the number of empty slots in the schedule.
    ///
    /// Returns the total number of schedule slots that don't currently
    /// have an activity assigned to them.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// let schedule = Schedule::new(2, 2, vec![1, 2].into_iter()); // 4 slots, 2 activities
    /// assert_eq!(schedule.empty_slots_count(), 2);
    /// ```
    pub fn empty_slots_count(&self) -> usize {
        self.slots.iter().filter(|opt| opt.is_none()).count()
    }

    /// Get direct access to the internal slots array.
    ///
    /// This method provides access to the underlying 2D array for advanced
    /// penalty function implementations that need to examine the schedule
    /// structure directly. The array is indexed as `slots[(place, time)]`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    /// use ndarray::Axis;
    ///
    /// #[derive(Clone)]
    /// struct Task { id: usize }
    ///
    /// let tasks = vec![Task { id: 1 }, Task { id: 2 }];
    /// let schedule = Schedule::new(2, 2, tasks.into_iter());
    ///
    /// // Count activities in each time slot
    /// for (time, row) in schedule.slots().axis_iter(Axis(1)).enumerate() {
    ///     let count = row.iter().filter(|slot| slot.is_some()).count();
    ///     println!("Time {}: {} activities", time, count);
    /// }
    /// ```
    pub fn slots(&self) -> &Array2<Option<A>> {
        &self.slots
    }

    fn reshuffle(&mut self) {
        use fastrand::usize as random_usize;

        // Collect all activities from both slots and unscheduled
        let mut all_activities = Vec::new();

        // Collect from slots
        for slot in self.slots.iter_mut() {
            if let Some(activity) = slot.take() {
                all_activities.push(activity);
            }
        }

        // Collect from unscheduled
        for unscheduled_slot in self.unscheduled.iter_mut() {
            if let Some(activity) = unscheduled_slot.take() {
                all_activities.push(activity);
            }
        }

        // Shuffle the activities
        for i in (1..all_activities.len()).rev() {
            let j = random_usize(0..=i);
            all_activities.swap(i, j);
        }

        // Redistribute activities: fill slots first, then unscheduled
        let mut activity_iter = all_activities.into_iter();

        // Fill slots
        for slot in self.slots.iter_mut() {
            if let Some(activity) = activity_iter.next() {
                *slot = Some(activity);
            }
        }

        // Fill unscheduled
        for unscheduled_slot in self.unscheduled.iter_mut() {
            if let Some(activity) = activity_iter.next() {
                *unscheduled_slot = Some(activity);
            }
        }
    }

    fn swap_locations(&mut self, loc1: Loc, loc2: Loc) {
        use Loc::*;

        let activity1 = match loc1 {
            S(p, t) => self.slots[(p, t)].take(),
            U(i) => self.unscheduled[i].take(),
        };
        let activity2 = match loc2 {
            S(p, t) => self.slots[(p, t)].take(),
            U(i) => self.unscheduled[i].take(),
        };

        match loc1 {
            S(p, t) => self.slots[(p, t)] = activity2,
            U(i) => self.unscheduled[i] = activity2,
        }
        match loc2 {
            S(p, t) => self.slots[(p, t)] = activity1,
            U(i) => self.unscheduled[i] = activity1,
        }
    }

    /// Create an improver for this schedule with the given penalty function.
    ///
    /// Returns an [`Improver`] that can be configured with various parameters
    /// before running the improvement.
    ///
    /// # Arguments
    ///
    /// * `penalty_fn` - Function that evaluates schedule quality. Lower scores are better.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Meeting { priority: usize }
    ///
    /// let mut schedule = Schedule::new(3, 5, vec![Meeting { priority: 10 }].into_iter());
    ///
    /// // Simple improvement
    /// schedule.improve(|s: &Schedule<Meeting>| {
    ///     let unscheduled_count = s.get_unscheduled_activities().count() + s.empty_slots_count();
    ///     let priority_penalty = s.get_unscheduled_activities().map(|m| m.priority as f32).sum::<f32>();
    ///     (unscheduled_count, priority_penalty)
    /// }).run();
    ///
    /// // With custom parameters
    /// schedule.improve(|s: &Schedule<Meeting>| {
    ///     let unscheduled_count = s.get_unscheduled_activities().count() + s.empty_slots_count();
    ///     let priority_penalty = s.get_unscheduled_activities().map(|m| m.priority as f32).sum::<f32>();
    ///     (unscheduled_count, priority_penalty)
    /// }).max_swaps(2000).with_noise().restarts(3).run();
    /// ```
    pub fn improve<F, P>(&mut self, penalty_fn: F) -> Improver<A, F>
    where
        F: Fn(&Schedule<A>) -> P,
        P: Copy + PartialOrd,
    {
        Improver::new(self, penalty_fn)
    }
}

impl<A: Clone> Schedule<A> {
    /// Run a complete improvement process with optional restarts.
    ///
    /// This method uses a hill-climbing algorithm to improve the schedule by
    /// trying swaps between different locations and keeping beneficial changes.
    /// You provide a penalty function that evaluates the quality of the schedule.
    ///
    /// The algorithm works by:
    /// 1. Trying all possible swaps between locations (schedule slots and unscheduled list)
    /// 2. Keeping the swap that gives the best improvement
    /// 3. Repeating until no improvement is found or max swaps reached
    /// 4. Optionally restarting with a random reshuffle to escape local optima
    ///
    /// # Arguments
    ///
    /// * `penalty_fn` - Function that takes a schedule reference and returns a penalty score.
    ///   Lower scores are better, with 0.0 representing a perfect solution.
    /// * `nswaps` - Maximum number of swap iterations per restart. If `None`,
    ///   defaults to `2 * (total_locations)^3`
    /// * `noise` - If `true`, occasionally makes random moves instead of greedy ones
    /// * `restarts` - Number of restarts with random reshuffling. If `None` or `0`,
    ///   no restarts are performed
    ///
    /// # Examples
    ///
    /// ```rust
    /// use time_scheduler::Schedule;
    ///
    /// #[derive(Clone)]
    /// struct Meeting {
    ///     priority: usize,
    ///     topic: usize,
    /// }
    ///
    /// let meetings = vec![
    ///     Meeting { priority: 10, topic: 1 },
    ///     Meeting { priority: 8, topic: 2 },
    ///     Meeting { priority: 6, topic: 1 },
    /// ];
    ///
    /// let mut schedule = Schedule::new(2, 2, meetings.into_iter());
    ///
    /// // Define penalty function returning (unscheduled_count, other_penalty)
    /// let penalty_fn = |schedule: &Schedule<Meeting>| {
    ///     let unscheduled_count = schedule.get_unscheduled_activities().count()
    ///                           + schedule.empty_slots_count();
    ///     let priority_penalty: f32 = schedule.get_unscheduled_activities()
    ///         .map(|m| m.priority as f32)
    ///         .sum();
    ///     
    ///     (unscheduled_count, priority_penalty)
    /// };
    ///
    /// // Improve with 5 restarts and noise
    /// schedule.improve(penalty_fn).with_noise().restarts(5).run();
    /// ```
    fn improve_run<F, P>(
        &mut self,
        penalty_fn: F,
        nswaps: Option<usize>,
        noise: bool,
        restarts: Option<usize>,
        timeout: Option<Duration>,
        proportional_restarts: bool,
    ) where
        F: Fn(&Schedule<A>) -> P,
        P: Copy + PartialOrd,
    {
        let num_restarts = restarts.unwrap_or(0);

        // Calculate per-run resources if proportional restarts are used
        let per_run_timeout = if proportional_restarts && timeout.is_some() && num_restarts > 1 {
            timeout.map(|t| Duration::from_nanos(t.as_nanos() as u64 / num_restarts as u64))
        } else {
            timeout
        };

        let per_run_nswaps = if proportional_restarts && num_restarts > 1 {
            nswaps.map(|n| n / num_restarts)
        } else {
            nswaps
        };

        // Single run case: optimize once and return (nrestarts <= 1 means no restarts)
        if num_restarts <= 1 {
            self.improve_single(&penalty_fn, per_run_nswaps, noise, per_run_timeout);
            return;
        }

        // Run first optimization and track as initial best
        self.improve_single(&penalty_fn, per_run_nswaps, noise, per_run_timeout);
        let mut best_penalty = penalty_fn(self);
        let mut best_schedule = self.clone();

        // Try additional restarts with reshuffling (num_restarts - 1 since we already did the initial run)
        for _ in 0..(num_restarts - 1) {
            self.reshuffle();
            self.improve_single(&penalty_fn, per_run_nswaps, noise, per_run_timeout);
            let current_penalty = penalty_fn(self);

            // Update best if this restart found a better solution
            if current_penalty < best_penalty {
                best_penalty = current_penalty;
                best_schedule = self.clone();
            }
        }

        // Restore the best solution found across all runs
        *self = best_schedule;
    }

    fn improve_single<F, P>(
        &mut self,
        penalty_fn: &F,
        nswaps: Option<usize>,
        noise: bool,
        timeout: Option<Duration>,
    ) where
        F: Fn(&Schedule<A>) -> P,
        P: Copy + PartialOrd,
    {
        use fastrand::usize as random_usize;
        use Loc::*;

        // Setup: calculate dimensions and generate all possible locations
        let (nplaces, ntimes) = self.slots.dim();
        let nunscheduled = self.unscheduled.len();
        let ntotal = nplaces * ntimes + nunscheduled;

        // Early return for empty schedules (no optimization possible)
        if ntotal == 0 {
            return;
        }
        // Default nswaps: 5 * ntotal^2
        // Rationale: Allows multiple cycles of greedy descent + noise escape.
        // Greedy search terminates naturally, but noisy search needs enough iterations
        // to escape local optima multiple times. Quadratic scaling accounts for the
        // roughly O(ntotal^2) possible swaps per iteration and allows ~5 exploration cycles.
        let nswaps = nswaps.unwrap_or(5 * ntotal * ntotal);

        let all_locations: Vec<Loc> = (0..nplaces)
            .flat_map(|p| (0..ntimes).map(move |t| S(p, t)))
            .chain((0..nunscheduled).map(U))
            .collect();

        // Initialize best solution tracking for this single run
        let mut best_penalty = penalty_fn(self);
        let mut best_schedule = self.clone();
        let mut penalty = best_penalty;

        // Initialize timeout checker if timeout is specified
        let mut timeout_checker = timeout.map(TimeoutChecker::new);

        // Main optimization loop: try up to nswaps improvements
        for swap_iter in 0..nswaps {
            // Check for timeout
            if let Some(ref mut checker) = timeout_checker {
                if checker.should_timeout(swap_iter) {
                    break;
                }
            }
            // Noise move: random swap that may disimprove (escape local optima)
            if noise && random_usize(0..2) == 0 {
                let i = random_usize(0..(nplaces * ntimes)); // Always pick from scheduled slots
                let mut j = random_usize(0..(ntotal - 1)); // Pick from reduced range
                if j >= i {
                    j += 1; // Skip over i to avoid self-swap
                }

                self.swap_locations(all_locations[i], all_locations[j]);
                let new_penalty = penalty_fn(self);

                // Always accept noise moves (even if they disimprove)
                penalty = new_penalty;

                // Update best if this noise move happened to improve
                if new_penalty < best_penalty {
                    best_penalty = new_penalty;
                    best_schedule = self.clone();
                }
                continue;
            }

            // Greedy move: find the best improving swap among all possibilities
            let mut cur_best = None;
            let mut cur_penalty = penalty;
            for i in 0..(nplaces * ntimes) {
                // Only iterate over scheduled slots
                for j in i + 1..ntotal {
                    // j can be any slot after i
                    // U-U swaps automatically avoided since i is always scheduled

                    self.swap_locations(all_locations[i], all_locations[j]);
                    let new_penalty = penalty_fn(self);
                    if cur_penalty > new_penalty {
                        cur_best = Some((i, j));
                        cur_penalty = new_penalty;
                    }
                    self.swap_locations(all_locations[j], all_locations[i]);
                }
            }
            // Apply the best greedy move if one was found
            if let Some((i, j)) = cur_best {
                self.swap_locations(all_locations[i], all_locations[j]);
                penalty = cur_penalty;

                // Update best if this greedy move improved our overall best
                if penalty < best_penalty {
                    best_penalty = penalty;
                    best_schedule = self.clone();
                }
            } else if !noise {
                // Pure greedy search: stop when no improvement found (local optimum reached)
                break;
            }
        }

        // Restore the best solution found during this single run
        *self = best_schedule;
    }
}
